Index: app/src/main/java/com/example/doug/checklistpresentlayer/BaseChecklist.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.doug.checklistpresentlayer\n\nimport android.content.Intent\nimport android.graphics.Color\nimport android.os.Bundle\nimport android.support.constraint.ConstraintLayout\nimport android.support.design.widget.NavigationView\nimport android.support.v4.view.GravityCompat\nimport android.support.v4.widget.DrawerLayout\nimport android.support.v7.app.ActionBar\nimport android.support.v7.app.AppCompatActivity\nimport android.support.v7.widget.Toolbar\nimport android.view.*\nimport android.widget.*\nimport com.google.gson.Gson\nimport kotlinx.android.synthetic.main.activity_base_checklist.*\nimport kotlinx.android.synthetic.main.history_popup.view.*\nimport kotlinx.android.synthetic.main.popup_layout.view.*\nimport kotlinx.android.synthetic.main.task_functions_layout.view.*\nimport kotlinx.android.synthetic.main.task_settings_deadline_popup.view.*\nimport kotlinx.android.synthetic.main.task_settings_name_change_popup.view.*\nimport kotlinx.android.synthetic.main.task_settings_popup.view.*\nimport kotlinx.android.synthetic.main.task_settings_recursion_popup.view.*\nimport kotlinx.coroutines.GlobalScope\nimport kotlinx.coroutines.launch\nimport java.io.File\nimport java.io.FileInputStream\nimport java.io.FileOutputStream\nimport kotlin.concurrent.thread\nimport android.widget.ImageButton\nimport android.widget.AdapterView\nimport android.widget.ListAdapter\nimport android.widget.RelativeLayout\n\n/********************************************\n *TO DO: Move listener assignments to functions\n ********************************************/\nclass BaseChecklist : AppCompatActivity(){\n\n    var currentChecklist = Checklist(\"Your Checklist\", 0 )\n\n    //Flag to see if any popups are present\n    var popupPresent = false\n\n    var currentTask: TaskBox? = null\n\n    private lateinit var userLayout: DrawerLayout\n    //private val mUserList = ArrayList<UserPage>()\n\n    //Intialize things here\n    init {\n\n    }\n\n    private fun createSettingsPopup() {\n        if (!popupPresent ) {\n            popupPresent = true\n\n            val mainView = findViewById<ScrollView>(R.id.TaskScrollView)\n\n            val popupSettingsWindow = PopupWindow(this)\n\n            val taskSettingsLayoutView =\n                layoutInflater.inflate(R.layout.task_settings_popup, null)\n\n            var taskCount = TaskLayout.childCount\n            var found = false\n            //Checks all current gui elements to see if they are checked\n            while (taskCount >= 0 && ! found) {\n                taskCount--\n\n                val currentChild = TaskLayout.getChildAt(taskCount)\n\n                if (currentChild is TaskBox) {\n                        if(currentChild == currentTask) {\n                        found = true\n                    }\n                }\n            }\n\n            popupSettingsWindow.contentView = taskSettingsLayoutView\n\n            /**************\n             *   Deadline Button Displays Deadline popup\n             ***************/\n            taskSettingsLayoutView.DeadlineButton.setOnClickListener {\n\n                popupSettingsWindow.dismiss()\n\n                val popupSettingsDeadlineWindow = PopupWindow(this)\n\n                val taskSettingsDeadlineLayoutView =\n                    layoutInflater.inflate(R.layout.task_settings_deadline_popup, null)\n\n                var tempString = \"\"\n\n                popupSettingsDeadlineWindow.contentView = taskSettingsDeadlineLayoutView\n\n                if(currentChecklist.tasks[taskCount].Deadline != null) {\n                    tempString =\n                        getString(R.string.CURRENT_DEADLINE_TEXT) + \" \" + currentChecklist.tasks[taskCount].Deadline.toString()\n\n                    taskSettingsDeadlineLayoutView.CurrentDeadlineTextView.text = tempString\n                }\n                else {\n                    taskSettingsDeadlineLayoutView.CurrentDeadlineTextView.text = getString(R.string.NO_DEADLINE_TEXT)\n                }\n\n                taskSettingsDeadlineLayoutView.ClearDeadlineButton.setOnClickListener {\n                    taskSettingsDeadlineLayoutView.CurrentDeadlineTextView.text = getString(R.string.NO_DEADLINE_TEXT)\n\n                    currentChecklist.removeDeadline(taskCount, User(1))\n                }\n\n                taskSettingsDeadlineLayoutView.DeadlineCalendarView.setOnDateChangeListener{_, year, month, day ->\n                    tempString =\n                        getString(R.string.CURRENT_DEADLINE_TEXT) + \" \" + day + \"/\" + month + \"/\" + year\n\n                    taskSettingsDeadlineLayoutView.CurrentDeadlineTextView.text = tempString\n\n                    currentChecklist.changeTaskDeadline(taskCount,User(1),\"$day/$month/$year\")\n                }\n\n                taskSettingsDeadlineLayoutView.closeDeadlineButton.setOnClickListener{\n\n                    popupSettingsDeadlineWindow.dismiss()\n\n                    popupPresent = false\n                }\n\n                popupSettingsDeadlineWindow.setOnDismissListener {\n                    popupPresent = false\n                }\n\n                popupSettingsDeadlineWindow.isFocusable = true\n\n                popupSettingsDeadlineWindow.showAtLocation(mainView, Gravity.CENTER, 0, 0)\n            }\n\n            /**************\n             *   Recursion Button Displays Task Recursion popup\n             ***************/\n            taskSettingsLayoutView.RecursionButton.setOnClickListener {\n\n                popupSettingsWindow.dismiss()\n\n                val popupSettingsRecurringWindow = PopupWindow(this)\n\n                val taskSettingsRecurringLayoutView =\n                    layoutInflater.inflate(R.layout.task_settings_recursion_popup, null)\n\n                popupSettingsRecurringWindow.contentView = taskSettingsRecurringLayoutView\n\n                taskSettingsRecurringLayoutView.CloseRecurringButton.setOnClickListener{\n\n                    popupSettingsRecurringWindow.dismiss()\n\n                    popupPresent = false\n                }\n\n                taskSettingsRecurringLayoutView.RecursionSwitch.isChecked =\n                    currentTask?.checkReccurring() != null && currentTask?.checkReccurring() == true\n\n                taskSettingsRecurringLayoutView.RecursionSwitch.setOnClickListener {\n                    currentTask?.toggleReccurringIfNotComplete()\n                }\n\n                popupSettingsRecurringWindow.setOnDismissListener {\n                    popupPresent = false\n                }\n\n                popupSettingsRecurringWindow.isFocusable = true\n\n                popupSettingsRecurringWindow.showAtLocation(mainView, Gravity.CENTER, 0, 0)\n            }\n\n            taskSettingsLayoutView.ChangeNameSettingsButton.setOnClickListener {\n\n                popupSettingsWindow.dismiss()\n\n                val popupSettingsChangeNameWindow = PopupWindow(this)\n\n                val taskSettingsChangeNameLayoutView =\n                    layoutInflater.inflate(R.layout.task_settings_name_change_popup, null)\n\n                popupSettingsChangeNameWindow.contentView = taskSettingsChangeNameLayoutView\n\n                taskSettingsChangeNameLayoutView.ChangeNameButton.setOnClickListener {\n\n                    val newName = taskSettingsChangeNameLayoutView.NewNameText.text.toString()\n\n                    currentTask?.ChangeName(newName)\n\n                    currentChecklist.changeTaskName(taskCount, User(1), newName)\n\n                    popupPresent = false\n\n                    popupSettingsChangeNameWindow.dismiss()\n                }\n\n                popupSettingsChangeNameWindow.setOnDismissListener {\n                    popupPresent = false\n                }\n\n                taskSettingsChangeNameLayoutView.ChangeNameCancelButton.setOnClickListener {\n                    popupPresent = false\n\n                    popupSettingsChangeNameWindow.dismiss()\n                }\n\n                popupSettingsChangeNameWindow.isFocusable = true\n\n                popupSettingsChangeNameWindow.showAtLocation(mainView, Gravity.CENTER, 0, 0)\n            }\n\n            taskSettingsLayoutView.CloseButton.setOnClickListener {\n                popupSettingsWindow.dismiss()\n                popupPresent = false\n            }\n\n            popupSettingsWindow.setOnDismissListener {\n                popupPresent = false\n            }\n\n            taskSettingsLayoutView.taskNameView.text = currentTask?.getTaskText()\n\n            popupSettingsWindow.isFocusable = true\n\n            popupSettingsWindow.showAtLocation(mainView, Gravity.CENTER, 0, 0)\n        }\n    }\n\n    fun createNewTask(TaskText: String, IsReaccuring: Boolean, taskID: Int?) {\n        var new_task_box = TaskBox(\n            this,\n            TaskText\n        )\n\n        if(IsReaccuring)\n            new_task_box.toggleReccurringIfNotComplete()\n\n        val mainView = findViewById<ScrollView>(R.id.TaskScrollView)\n\n        //Adds the task to the checklist\n        currentChecklist.createTask(TaskText, null, User(intent.getIntExtra(\"UserID\", 0)), null, currentChecklist.listID!!)\n\n        //rebuild the local file with the updated checklist\n        GlobalScope.launch {\n            deleteListDataFile()\n            createListFile(currentChecklist)\n        }\n\n        val popupFunctionWindow = PopupWindow(this)\n\n        val taskFunctionLayoutView =\n            layoutInflater.inflate(R.layout.task_functions_layout, null)\n\n        taskFunctionLayoutView.FunctionCloseButton.setOnClickListener {\n            popupFunctionWindow.dismiss()\n\n            popupPresent = false\n        }\n\n        taskFunctionLayoutView.FunctionSettingsButton.setOnClickListener {\n            popupFunctionWindow.dismiss()\n\n            popupPresent = false\n\n            createSettingsPopup()\n        }\n\n        //Sets the delete button to remove the task\n        taskFunctionLayoutView.FunctionDeleteButton.setOnClickListener {\n            for(i in TaskLayout.childCount downTo 0 step 1)\n            {\n                val tempChild = TaskLayout.getChildAt(i)\n                if(tempChild is TaskBox)\n                {\n                    if(tempChild == currentTask)\n                    {\n                        TaskLayout.removeView(TaskLayout.getChildAt(i))\n                        //remove the task from the list, and delete it from the database\n                        currentChecklist.deleteTask(i, User(1))\n\n                        //update the local file\n                        GlobalScope.launch {\n                            deleteListDataFile()\n                            createListFile(currentChecklist)\n                        }\n                    }\n                }\n            }\n\n            popupFunctionWindow.dismiss()\n\n            popupPresent = false\n        }\n\n        popupFunctionWindow.contentView = taskFunctionLayoutView\n\n        popupFunctionWindow.setOnDismissListener {\n            PopupWindow.OnDismissListener {\n                popupPresent = false\n            }\n        }\n\n        //Sets the on lick listener for the new task gui element\n        new_task_box.setOnClickListener{\n\n            if(!popupPresent) {\n\n                popupPresent = true\n\n                popupFunctionWindow.isFocusable()\n\n                popupFunctionWindow.showAtLocation(mainView, Gravity.CENTER, 0, 0)\n\n                for(i in TaskLayout.childCount downTo 0 step 1)\n                {\n                    val tempChild = TaskLayout.getChildAt(i)\n                    if(tempChild is TaskBox)\n                    {\n                        if(tempChild == new_task_box) {\n                            currentTask = tempChild\n                        }\n                    }\n                }\n            }\n        }\n\n        val taskLayout = findViewById<LinearLayout>(R.id.TaskLayout)\n\n        taskLayout.addView(new_task_box)\n    }\n\n    fun addTask(task: Task) {\n        var new_task_box = TaskBox(\n            this,\n            task.name\n        )\n\n        if(task.isRecurring == true)\n            new_task_box.toggleReccurringIfNotComplete()\n\n        val mainView = findViewById<ScrollView>(R.id.TaskScrollView)\n\n        //Adds the task to the checklist\n        currentChecklist.tasks.add(task)\n\n        val popupFunctionWindow = PopupWindow(this)\n\n        val taskFunctionLayoutView =\n            layoutInflater.inflate(R.layout.task_functions_layout, null)\n\n        taskFunctionLayoutView.FunctionCloseButton.setOnClickListener {\n            popupFunctionWindow.dismiss()\n\n            popupPresent = false\n        }\n\n        taskFunctionLayoutView.FunctionSettingsButton.setOnClickListener {\n            popupFunctionWindow.dismiss()\n\n            popupPresent = false\n\n            createSettingsPopup()\n        }\n\n        //Sets the delete button to remove the task\n        taskFunctionLayoutView.FunctionDeleteButton.setOnClickListener {\n            for(i in TaskLayout.childCount downTo 0 step 1)\n            {\n                val tempChild = TaskLayout.getChildAt(i)\n                if(tempChild is TaskBox)\n                {\n                    if(tempChild == currentTask)\n                    {\n                        TaskLayout.removeView(TaskLayout.getChildAt(i))\n                        currentChecklist.deleteTask(i, User(1));\n                    }\n                }\n            }\n\n            popupFunctionWindow.dismiss()\n\n            popupPresent = false\n        }\n\n        popupFunctionWindow.contentView = taskFunctionLayoutView\n\n        popupFunctionWindow.setOnDismissListener {\n            PopupWindow.OnDismissListener {\n                popupPresent = false\n            }\n        }\n\n        //Sets the on lick listener for the new task gui element\n        new_task_box.setOnClickListener{\n\n            if(!popupPresent) {\n\n                popupPresent = true\n\n                popupFunctionWindow.isFocusable()\n\n                popupFunctionWindow.showAtLocation(mainView, Gravity.CENTER, 0, 0)\n\n                for(i in TaskLayout.childCount downTo 0 step 1)\n                {\n                    val tempChild = TaskLayout.getChildAt(i)\n                    if(tempChild is TaskBox)\n                    {\n                        if(tempChild == new_task_box) {\n                            currentTask = tempChild\n                        }\n                    }\n                }\n            }\n        }\n\n        val taskLayout = findViewById<LinearLayout>(R.id.TaskLayout)\n\n        taskLayout.addView(new_task_box)\n    }\n\n    fun addTaskFromList(task: Task) {\n        var new_task_box = TaskBox(\n            this,\n            task.name\n        )\n\n        if(task.isRecurring == true)\n            new_task_box.toggleReccurringIfNotComplete()\n\n        val mainView = findViewById<ScrollView>(R.id.TaskScrollView)\n\n        val popupFunctionWindow = PopupWindow(this)\n\n        val taskFunctionLayoutView =\n            layoutInflater.inflate(R.layout.task_functions_layout, null)\n\n        taskFunctionLayoutView.FunctionCloseButton.setOnClickListener {\n            popupFunctionWindow.dismiss()\n\n            popupPresent = false\n        }\n\n        taskFunctionLayoutView.FunctionSettingsButton.setOnClickListener {\n            popupFunctionWindow.dismiss()\n\n            popupPresent = false\n\n            createSettingsPopup()\n        }\n\n        //Sets the delete button to remove the task\n        taskFunctionLayoutView.FunctionDeleteButton.setOnClickListener {\n            for(i in TaskLayout.childCount downTo 0 step 1)\n            {\n                val tempChild = TaskLayout.getChildAt(i)\n                if(tempChild is TaskBox)\n                {\n                    if(tempChild == currentTask)\n                    {\n                        TaskLayout.removeView(TaskLayout.getChildAt(i))\n                        currentChecklist.deleteTask(i, User(1))\n\n                        //remake the local file\n                        GlobalScope.launch {\n                            deleteListDataFile()\n                            createListFile(currentChecklist)\n                        }\n                    }\n                }\n            }\n\n            popupFunctionWindow.dismiss()\n\n            popupPresent = false\n        }\n\n        popupFunctionWindow.contentView = taskFunctionLayoutView\n\n        popupFunctionWindow.setOnDismissListener {\n            PopupWindow.OnDismissListener {\n                popupPresent = false\n            }\n        }\n\n        //Sets the on lick listener for the new task gui element\n        new_task_box.setOnClickListener{\n\n            if(!popupPresent) {\n\n                popupPresent = true\n\n                popupFunctionWindow.isFocusable()\n\n                popupFunctionWindow.showAtLocation(mainView, Gravity.CENTER, 0, 0)\n\n                for(i in TaskLayout.childCount downTo 0 step 1)\n                {\n                    val tempChild = TaskLayout.getChildAt(i)\n                    if(tempChild is TaskBox)\n                    {\n                        if(tempChild == new_task_box) {\n                            currentTask = tempChild\n                        }\n                    }\n                }\n            }\n        }\n\n        val taskLayout = findViewById<LinearLayout>(R.id.TaskLayout)\n\n        taskLayout.addView(new_task_box)\n    }\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_base_checklist)\n        currentChecklist.listID = intent.getIntExtra(\"ChecklistID\", 0)\n        //line below gets the checklist name so that each checklist correctly\n        //displays their own tasks and no other checklist's tasks\n        currentChecklist.i_name = intent.getStringExtra(\"ListName\")\n\n        //create a database access object\n        var db = Database()\n\n        //test code. replace with database/local storage call.\n        currentChecklist.addUser(User(1,\"Sally123\",\"Suzan\",\"McPoyle\", \"none\"))\n        currentChecklist.addUser(User(2,\"Roger123\",\"Roger\",\"McPoyle\", \"none\"))\n        currentChecklist.addUser(User(3,\"Rufus123\",\"Rufus\",\"McPoyle\", \"none\"))\n        currentChecklist.addUser(User(4,\"Gorgina123\",\"Gorgina\",\"McPoyle\", \"none\"))\n        //test code. replace with database/local storage call.\n\n\n        //if there's a local file, populate our list from that\n        if (listFileExists()){\n            //deleteListDataFile()\n            currentChecklist = getListFromFile()\n\n            //add each task in currentChecklist to the page\n            for (Task in currentChecklist.tasks){\n                addTaskFromList(Task)\n            }\n\n            println(\"loaded list from local file\")\n\n            //in a new thread, get checklist data from the database to see if any changes\n            //have happened since last opened.\n            //if there's only one user on the list, don't do anything\n            if (!currentChecklist.users.isEmpty()) {\n                //THIS COMMENT BLOCK IS FOR MATT TODO\n                //globalscope.launch starts a new thread, where all this will happen.\n                //we DO NOT want the user to be able to change anything in their list while this thread is active.\n                //we need code that will check if this thread is active in the thread pool.\n                //on the surface, the app will look exactly the same, but there will be some sort of \"wait\" that happens\n                //if the user tries to change something and this is still going on\n                GlobalScope.launch {\n                    /*Right here start up a loading swirly*/\n                    var list = db.GetChecklist(currentChecklist.cListID!!)\n\n                    if (list != currentChecklist){\n                        /*have a popup or something telling the user that the list has been updated*/\n                        currentChecklist = list\n                    }\n                }\n            }\n        }\n\n        //if no local file exists, populate our list from the database\n        else{\n            println(\"loaded list from database\")\n            var currentTasks = db.GetTasks(intent.getIntExtra(\"ChecklistID\", 0))\n\n            for (Task in currentTasks)\n            {\n                if (Task.name != \"\")\n                    addTask(Task)\n            }\n\n            //create a local file with the data\n            GlobalScope.launch {\n                createListFile(currentChecklist)\n            }\n        }\n\n        //allows the opening and closing of a nav drawer on the right side of the screen.\n        userLayout = findViewById(R.id.user_drawer_layout)\n        val menuRight = findViewById<View>(R.id.menuRight) as ImageButton\n        menuRight.setOnClickListener {\n            if (userLayout.isDrawerOpen(GravityCompat.END)) {\n                userLayout.closeDrawer(GravityCompat.END)\n            } else {\n                userLayout.openDrawer(GravityCompat.END)\n            }\n        }\n        //creates a submenu named user\n        val subMenu: SubMenu\n        val navigationView: NavigationView = findViewById(R.id.nav_view)\n        val menu = navigationView.menu\n        subMenu = menu.addSubMenu(getString(R.string.SUB_MENU_TITLE))\n\n        //populates the submenu with the usernames of everyone on the list (stored in mUserList\n        //Menu.FIRST + i gives each a unique ID, used later in the program.\n        for ((i, up) in currentChecklist.users.withIndex()) {\n            subMenu.add(0, Menu.FIRST + i, Menu.FIRST, up.Username)\n        }\n\n        //gets called whenever any item is selected in the nav menu\n        navigationView.setNavigationItemSelectedListener { menuItem ->\n            //handles all items in nav drawer that are created at compile time\n            if (!onOptionsItemSelected(menuItem))\n            {\n                //handles all items in nav drawer that are created at run time\n                val id = menuItem.itemId - Menu.FIRST\n                if (id < currentChecklist.users.size && id >= 0) {\n                    val up = currentChecklist.users[id]\n                    val tempIntent = Intent(this, UserLogin::class.java).apply {\n                        putExtra(\"id\", up.UserID)\n                        putExtra(\"uname\", up.Username)\n                        putExtra(\"fname\", up.FName)\n                        putExtra(\"lname\", up.LName)\n                    }\n                    startActivity(tempIntent)\n                }\n            }\n            // close drawer when item is tapped\n            userLayout.closeDrawers()\n            // Add code here to update the UI based on the item selected\n            // For example, swap UI fragments here\n\n            true\n        }\n\n        val addButton = findViewById<Button>(R.id.AddTaskButton)\n        val checkoffButton = findViewById<Button>(R.id.CheckoffButton)\n        val historyButton = findViewById<Button>(R.id.HistoryButton)\n\n        //Creates the click listener for the add button\n        val addListener = View.OnClickListener {\n\n                //If there is not a popup already [resent\n            if(!popupPresent) {\n\n                //Get the view containing all the tasks\n                val mainView = findViewById<ScrollView>(R.id.TaskScrollView)\n\n                val popupWindow = PopupWindow(this)\n                //Create a view that is of the popup_layout in resources\n                val popupView = layoutInflater.inflate(R.layout.popup_layout, null)\n                //Sets the content of the popup to the popup_layout\n                popupWindow.contentView = popupView\n                //Retrieves the acceptButton from the popup\n                val acceptButton = popupView.PopupMainView.AcceptButton\n\n                //Creates and adds the on click action to the add button\n                acceptButton.setOnClickListener{\n\n                        val popup_edittext = popupView.PopupMainView.PopupEditText\n\n                        //Retrieves the name of the task if the name is long enough\n                        if (popup_edittext.text.toString().length >= 1) {\n                            createNewTask(popup_edittext.text.toString(), false, 0/*needs to be something later*/)\n                            //currentChecklist.createTask(popup_edittext.text.toString(),\n                            //   \"none\", User(intent.getIntExtra(\"UserID\", 0)))\n                        }\n\n                    //Set dismiss listener\n                    popupWindow.setOnDismissListener {\n                        popupPresent = false\n                    }\n                    //Dismisses the popup\n                    popupWindow.dismiss()\n                }\n                //Set cancel button to dismiss the popup\n                val cancelButton = popupView.PopupMainView.CancelButton\n\n                cancelButton.setOnClickListener(View.OnClickListener {\n\n                    popupWindow.dismiss()\n\n                })\n                //Have the popup clean up items when dismissed\n                popupWindow.setOnDismissListener(PopupWindow.OnDismissListener {\n                    val popupEdittext = popupView.PopupMainView.PopupEditText\n\n                    popupEdittext.text.clear()\n\n                    popupPresent = false\n                })\n\n                popupWindow.isFocusable = true\n\n                popupWindow.showAtLocation(mainView, Gravity.CENTER, 0, 0)\n\n                popupPresent = true\n\n            }\n        }\n\n        addButton.setOnClickListener(addListener)\n        //Create the click listener for the checkoff button\n        val checkoffListener = View.OnClickListener {\n\n            var taskCount = TaskLayout.childCount - 1\n            //Checks all current gui elements to see if they are checked\n            while (taskCount >= 0)\n            {\n                val currentChild = TaskLayout.getChildAt(taskCount)\n\n                if(currentChild is TaskBox)\n                {\n                    val taskSwitch = currentChild.getChildAt(1)\n\n                    if(taskSwitch is Switch)\n                    {\n                        if(taskSwitch.isChecked)\n                        {\n                            if(!currentChild.checkCompletion()) {\n                                if (currentChild.checkReccurring()) {\n                                    createNewTask(currentChild.getTaskText(), true, 0/*needs to be something later*/)\n                                    //currentChecklist.createTask(currentChild.getTaskText(), \"enable Later\", User(1))\n                                }\n\n                                currentChild.completeTask()\n\n                                //TaskLayout.removeView(TaskLayout.getChildAt(taskCount))\n\n                                currentChecklist.completeTask(taskCount, User(1))\n                            }\n                        }\n                    }\n                }\n\n                taskCount--\n            }\n        }\n\n        checkoffButton.setOnClickListener(checkoffListener)\n\n        //Set history button's click listener\n\n        val historyListener = View.OnClickListener {\n            //Toast.makeText(this, \"General Kenobi!\", Toast.LENGTH_SHORT).show()\n\n            if(!popupPresent) {\n\n                val mainViewHistory = findViewById<ScrollView>(R.id.TaskScrollView)\n\n                val popupWindowHistory = PopupWindow(this)\n\n                val popupViewHistory = layoutInflater.inflate(R.layout.history_popup, null)\n\n                popupWindowHistory.contentView = popupViewHistory\n\n\n                val cancelListener = View.OnClickListener {\n                    popupWindowHistory.dismiss()\n                }\n\n                val dismissListener = PopupWindow.OnDismissListener {\n                    popupPresent = false\n                }\n\n                popupWindowHistory.setOnDismissListener(dismissListener)\n\n                popupViewHistory.HistoryCloseButton.setOnClickListener(cancelListener)\n\n                popupPresent = true\n\n                popupWindowHistory.isFocusable = true\n\n                val historyIterator = currentChecklist.changes.iterator()\n\n                val historyLayout = popupViewHistory.HistoryLinearLayout\n\n                //Check to see if not changes have happened\n                //Displays a message for each change that has occurred\n                if(currentChecklist.changes.isEmpty()) {\n                    val checklistChangeTextView = TextView(this)\n\n                    var toAddString = \"No Changes in this checklist!\"\n\n                    checklistChangeTextView.text = toAddString\n\n                    checklistChangeTextView.setTextColor(Color.WHITE)\n\n                    checklistChangeTextView.textSize = 30f\n                    checklistChangeTextView.layoutParams = LinearLayout.LayoutParams(\n                        LinearLayout.LayoutParams.WRAP_CONTENT,\n                        ViewGroup.LayoutParams.WRAP_CONTENT\n                    )\n\n                    historyLayout.addView(checklistChangeTextView)\n                }\n                else {\n                    historyIterator.forEach {\n\n                        val checklistChangeTextView = TextView(this)\n\n                        var toAddString = \"Default\"\n\n                        when(it.changeType) {\n\n                            kAction.CREATE_TASK -> toAddString = \"--- Task Added: \" + it.taskName +\n                                    \"\\n    Added By: Current User\\n\"\n                            kAction.DELETE_TASK -> toAddString = \"--- Task Deleted: \" + it.taskName +\n                                    \"\\n    Deleted By: Current User\\n\"\n                            kAction.COMPLETE_TASK -> toAddString = \"--- Task Completed: \" + it.taskName +\n                                    \"\\n    Completed By: Current User\\n\"\n                        }\n\n                        checklistChangeTextView.text = toAddString\n\n                        checklistChangeTextView.setTextColor(Color.WHITE)\n\n                        checklistChangeTextView.textSize = 20f\n                        checklistChangeTextView.layoutParams = LinearLayout.LayoutParams(\n                            LinearLayout.LayoutParams.WRAP_CONTENT,\n                            ViewGroup.LayoutParams.WRAP_CONTENT\n                        )\n\n                        historyLayout.addView(checklistChangeTextView)\n                    }\n                }\n\n                popupWindowHistory.showAtLocation(mainViewHistory, Gravity.CENTER, 0, 0)\n            }\n        }\n\n        historyButton.setOnClickListener(historyListener)\n    }\n\n    fun createListFile(list: Checklist) {\n        //convert list to a JSON string\n        val gson = Gson()\n        val userJson = gson.toJson(list)\n\n        //context will give us access to our local files directory\n        var context = applicationContext\n\n        val filename = list.i_name\n        val directory = context.filesDir\n\n        //write the file to local directory\n        //the filename will be the name of the list\n        val file = File(directory, filename)\n        FileOutputStream(file).use {\n            it.write(userJson.toByteArray())\n        }\n    }\n\n    fun listFileExists() : Boolean {\n        return File(applicationContext.filesDir, currentChecklist.i_name).exists()\n    }\n\n    //we don't have to check if the file exists in this function\n    //because we call listFileExists() before calling this\n    //however, we might need some other error checking in here\n    fun getListFromFile() : Checklist {\n        //context will give us access to our local files directory\n        var context = applicationContext\n\n        val filename = currentChecklist.i_name\n        val directory = context.filesDir\n\n        //read from the file and store it as a string\n        val file = File(directory, filename)\n        val fileData = FileInputStream(file).bufferedReader().use { it.readText() }\n\n        //create a Checklist object based on the JSON from the file\n        val gson = Gson()\n        return gson.fromJson(fileData, Checklist::class.java)\n    }\n\n    fun deleteListDataFile(){\n        //context will give us access to our local files directory\n        var context = applicationContext\n\n        val filename = currentChecklist.i_name\n        val directory = context.filesDir\n\n        //delete the file\n        File(directory, filename).delete()\n    }\n    override fun onOptionsItemSelected(item: MenuItem): Boolean {\n        //handles all nav drawer activity that was added at run time.\n        return when (item.itemId) {\n            android.R.id.home -> {\n                userLayout.openDrawer(GravityCompat.START)\n                true\n            }\n            R.id.dAddUser -> {\n                //addusercodehere\n\n                true\n            }\n            else -> super.onOptionsItemSelected(item)\n        }\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/example/doug/checklistpresentlayer/BaseChecklist.kt	(revision 6ba74c53ce796d2c7203635a067f5836e335ec4a)
+++ app/src/main/java/com/example/doug/checklistpresentlayer/BaseChecklist.kt	(date 1555205330547)
@@ -558,6 +558,7 @@
                 //on the surface, the app will look exactly the same, but there will be some sort of "wait" that happens
                 //if the user tries to change something and this is still going on
                 GlobalScope.launch {
+
                     /*Right here start up a loading swirly*/
                     var list = db.GetChecklist(currentChecklist.cListID!!)
 
@@ -565,6 +566,7 @@
                         /*have a popup or something telling the user that the list has been updated*/
                         currentChecklist = list
                     }
+
                 }
             }
         }
